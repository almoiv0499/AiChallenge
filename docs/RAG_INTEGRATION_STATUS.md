# Статус интеграции RAG в системе

## Текущее использование RAG

### ✅ Где используется

**1. Команда `/help <вопрос>` (Main.kt)**
```kotlin
// Файл: src/main/kotlin/org/example/Main.kt
// Функция: handleHelpByProject()

val searchResults = ragService.search(question, limit = 2, minSimilarity = 0.3)
```
- **Когда:** Только при явной команде `/help <вопрос>`
- **Что делает:** Ищет релевантные фрагменты в документации проекта
- **Результат:** Показывает найденную информацию из документации

### ❌ Где НЕ используется

**1. В OpenRouterAgent**
- `ragService` передается в конструктор, но **никогда не вызывается**
- Системный промпт статический, без контекста проекта
- Обычные сообщения обрабатываются без RAG контекста

**2. Для Project Task API**
- Инструменты работают напрямую через HTTP клиент
- Нет автоматического получения контекста проекта
- Агент не знает о текущем состоянии проекта из документации

## Проблема

Когда пользователь спрашивает:
- "Какие задачи критичны для релиза?"
- "Есть ли риски, что мы не уложимся в дедлайн?"
- "Что сейчас лучше делать: фиксить баги или добавлять фичи?"

Агент:
- ✅ Может получить задачи через `get_project_tasks`
- ✅ Может получить статус через `get_project_status`
- ❌ НО не знает контекст проекта из документации (roadmap, дедлайны, приоритеты, договорённости)

## Решение: Интеграция RAG для Project Task API

### Вариант 1: Автоматический RAG контекст при запросах о задачах

**Когда использовать:**
- При запросах, связанных с задачами проекта
- При вопросах о статусе, приоритетах, дедлайнах

**Как работает:**
1. Определяем, что запрос связан с задачами проекта
2. Используем RAG для поиска релевантного контекста (roadmap, дедлайны, приоритеты)
3. Добавляем найденный контекст в системный промпт или в запрос к агенту
4. Агент использует контекст + данные из API для ответа

**Пример:**
```
Пользователь: "Какие задачи критичны для релиза?"

1. RAG ищет: "релиз", "критические задачи", "дедлайн релиза"
2. Находит: "Релиз запланирован на 15 февраля. Критичные задачи: интеграция платежей, исправление багов авторизации"
3. Контекст добавляется к запросу
4. Агент использует контекст + get_project_tasks для ответа
```

### Вариант 2: RAG контекст в системном промпте

**Когда использовать:**
- При инициализации агента
- Периодически обновлять контекст

**Как работает:**
1. При старте агента используем RAG для получения общего контекста проекта
2. Добавляем контекст в системный промпт
3. Агент всегда имеет актуальный контекст проекта

**Пример системного промпта:**
```
Ты — помощник проекта. 

Контекст проекта (из документации):
- Текущий этап: MVP
- Релиз запланирован на 15 февраля 2025
- Критичные компоненты: платежи, авторизация
- Команда: 3 разработчика, 1 дизайнер

У тебя есть доступ к инструментам для работы с задачами...
```

### Вариант 3: Гибридный подход (рекомендуется)

**Когда использовать:**
- Комбинация вариантов 1 и 2

**Как работает:**
1. **При старте:** Добавляем общий контекст проекта в системный промпт
2. **При запросах о задачах:** Дополнительно ищем специфичный контекст через RAG
3. **При анализе приоритетов:** Используем RAG для понимания бизнес-логики

## Реализация

### Шаг 1: Определение релевантности запроса

```kotlin
private fun isProjectTaskRelatedQuery(message: String): Boolean {
    val keywords = listOf(
        "задача", "задачи", "проект", "статус", "приоритет",
        "дедлайн", "релиз", "milestone", "критичн", "блокер"
    )
    return keywords.any { message.contains(it, ignoreCase = true) }
}
```

### Шаг 2: Получение RAG контекста

```kotlin
private suspend fun getProjectContext(query: String): String {
    if (ragService == null) return ""
    
    val results = ragService.search(query, limit = 3, minSimilarity = 0.5)
    if (results.isEmpty()) return ""
    
    return results.joinToString("\n\n") { 
        "Из документации проекта:\n${it.text}"
    }
}
```

### Шаг 3: Интеграция в processMessage

```kotlin
suspend fun processMessage(userMessage: String): ChatResponse {
    // Если запрос связан с задачами проекта
    if (isProjectTaskRelatedQuery(userMessage) && ragService != null) {
        val context = getProjectContext(userMessage)
        if (context.isNotEmpty()) {
            // Добавляем контекст к сообщению пользователя
            val enrichedMessage = """
                Контекст проекта:
                $context
                
                Вопрос пользователя: $userMessage
            """.trimIndent()
            addUserMessage(enrichedMessage)
        } else {
            addUserMessage(userMessage)
        }
    } else {
        addUserMessage(userMessage)
    }
    
    return executeAgentLoop()
}
```

## Преимущества интеграции

1. **Контекстуальные ответы:** Агент знает о проекте из документации
2. **Умные рекомендации:** Может учитывать roadmap, дедлайны, приоритеты
3. **Автоматизация:** Не нужно явно запрашивать контекст через `/help`
4. **Точность:** Ответы основаны на актуальной документации + данных из API

## Примеры работы с RAG

### Без RAG (текущее состояние):
```
Пользователь: "Какие задачи критичны для релиза?"
Агент: [использует get_project_tasks с priority=CRITICAL]
       Показывает список критических задач
       ❌ Не знает, что такое "релиз" в контексте проекта
```

### С RAG (после интеграции):
```
Пользователь: "Какие задачи критичны для релиза?"
Агент: [RAG находит: "Релиз MVP запланирован на 15 февраля"]
       [использует get_project_tasks с priority=CRITICAL]
       [использует get_project_status]
       Показывает критичные задачи + контекст:
       "Для релиза MVP (15 февраля) критичны следующие задачи..."
       ✅ Знает контекст проекта
```

## Следующие шаги

1. ✅ Определить, когда использовать RAG (критерии релевантности)
2. ✅ Интегрировать RAG в processMessage для автоматического контекста
3. ✅ Добавить RAG контекст в системный промпт при старте
4. ✅ Протестировать на реальных запросах

## Текущий статус

- ✅ RAG интегрирован для Project Task API
- ✅ RAG используется в основном цикле агента (processMessage)
- ✅ RAG контекст добавляется в системный промпт при старте
- ✅ RAG работает для команды `/help`
- ✅ Автоматическое определение релевантности запросов
- ✅ Инфраструктура RAG полностью используется

## Реализация завершена

См. `docs/RAG_INTEGRATION_IMPLEMENTATION.md` для деталей реализации.
